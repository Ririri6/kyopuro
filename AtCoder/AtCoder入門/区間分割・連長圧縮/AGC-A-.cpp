#include <bits/stdc++.h>
using namespace std;
 
int main() {
  string S;
    cin >> S;
    int N = S.size();

    vector<int> L(N + 1, 0);
    vector<int> R(N + 1, 0);

    // 左から '<' を数える
    for (int i = 0; i < N; ++i) {
        if (S[i] == '<') {
            L[i + 1] = L[i] + 1;
        }
    }

    // 右から '>' を数える
    for (int i = N - 1; i >= 0; --i) {
        if (S[i] == '>') {
            R[i] = R[i + 1] + 1;
        }
    }

    long long total = 0;
    for (int i = 0; i <= N; ++i) {
        total += max(L[i], R[i]);
    }

    cout << total << endl;
    return 0;
}
/*
----「左右からの条件を同時に満たす」系の問題---
| 観点            | 解説                                            |
| ------------- | --------------------------------------------- |
| **山型構造の認識**   | `<` が増加、`>` が減少で、最小値を作るには左右の山の高さをうまく合わせる必要がある |
| **左右からの累積処理** | 二方向からのスキャンで条件を処理するという基本手法                     |
| **最大値を取る発想**  | 2つの候補があるとき、「必要な条件を満たす最小の数」は `max()` になるケースが多い |

視点1：「山型構造」とは何か？
・< の連続は 登り坂（増加） → 値を1ずつ増やす必要がある
・> の連続は 下り坂（減少） → 値を1ずつ減らす必要がある（けど負にはできない）
・つまり、最小の合計にするには「登り」と「下り」の重なり（山頂）を最小にしたい

視点2：各位置ごとに「必要な高さ」を左右から独立に見る
・「この場所が何段目か」は、左側から見ると何段登ってきたか（<の長さ）
・同様に、右側から見ると何段下りるか（>の長さ）
・なので、最も高い方（= max(left, right)）だけあれば、両方の条件を満たす



*/